# py-libtea v0.2.0 Design Document

**Goal:** Bring py-libtea to full TEA v0.3.0-beta.2 spec compliance by adding CLE endpoints, SemVer-based endpoint selection, endpoint failover with retry, and mTLS/basic auth support.

**Spec version:** TEA v0.3.0-beta.2 (OpenAPI 3.1.1) — [Ecma TC54-TG1](https://tc54.org/tea/) | [GitHub](https://github.com/CycloneDX/transparency-exchange-api)

**CLE spec:** ECMA-428 v1.0.0 — [Ecma International](https://ecma-international.org/publications-and-standards/standards/ecma-428/)

---

## Scope

### In scope (v0.2.0)

| Feature | Spec requirement | Effort |
|---------|-----------------|--------|
| CLE endpoints (4 new) + models (6 new) | Spec-defined, added Feb 2026 | Medium |
| SemVer version matching in endpoint selection | Spec: "MUST prioritize ... based on SemVer 2.0.0" | Small |
| Endpoint failover with exponential backoff | Spec: "MUST retry ... with the next endpoint" | Medium |
| mTLS support (client certificates) | Spec: one of two auth methods | Small |
| Basic auth support | Spec: defined in OpenAPI security schemes | Small |
| CLI (`tea-cli`) via typer | User-facing tool, like rearm's `tea` subcommand | Medium |
| Remove all regexes | Code quality: replace with plain string operations | Small |
| `fetch_well_known` scheme/port params | Parity with rearm's `--usehttp`/`--useport` | Small |
| `DiscoveryInfo.servers` `min_length=1` | Spec: `minItems: 1` | Trivial |
| `IdentifierType.UDI` disclaimer | UDI not in spec's `identifier-type` enum | Trivial |

### Out of scope (deferred)

| Feature | Reason |
|---------|--------|
| Async client (`AsyncTeaClient` via httpx) | Deferred to v0.3.0 |
| Publisher API | Blocked on TEA spec — see `docs/FUTURE.md` |
| Pagination auto-iteration | Convenience, not spec-required |
| Interactive disambiguation | Future CLI enhancement |

---

## 1. CLE (Common Lifecycle Enumeration)

### Endpoints

Four new GET endpoints, no pagination, no query parameters:

| Path | Method | Client method | Return type |
|------|--------|---------------|-------------|
| `/product/{uuid}/cle` | GET | `get_product_cle(uuid)` | `CLE` |
| `/productRelease/{uuid}/cle` | GET | `get_product_release_cle(uuid)` | `CLE` |
| `/component/{uuid}/cle` | GET | `get_component_cle(uuid)` | `CLE` |
| `/componentRelease/{uuid}/cle` | GET | `get_component_release_cle(uuid)` | `CLE` |

All return the same `CLE` schema. HTTP status codes: 200, 400, 404.

Design decision: CLE was moved to dedicated endpoints (not nested in objects) because CLE documents can grow large. See [PR #213](https://github.com/CycloneDX/transparency-exchange-api/pull/213), decided at TC54-TG1 meeting 2026-02-19.

### Data models

Add to `libtea/models.py`:

#### `CLEEventType` (StrEnum)

```python
class CLEEventType(StrEnum):
    RELEASED = "released"
    END_OF_DEVELOPMENT = "endOfDevelopment"
    END_OF_SUPPORT = "endOfSupport"
    END_OF_LIFE = "endOfLife"
    END_OF_DISTRIBUTION = "endOfDistribution"
    END_OF_MARKETING = "endOfMarketing"
    SUPERSEDED_BY = "supersededBy"
    COMPONENT_RENAMED = "componentRenamed"
    WITHDRAWN = "withdrawn"
```

Note: CLE event types are **camelCase strings** (not UPPER_SNAKE_CASE like other TEA enums). This is per ECMA-428 spec.

#### `CLEVersionSpecifier`

```python
class CLEVersionSpecifier(_TeaModel):
    version: str | None = None      # Specific version (e.g. "1.0.0")
    range: str | None = None        # vers format range (e.g. "vers:npm/>=1.0.0|<2.0.0")
```

At least one of `version` or `range` should be present.

#### `CLEEvent`

```python
class CLEEvent(_TeaModel):
    # Required
    id: int
    type: CLEEventType
    effective: datetime
    published: datetime

    # Optional — contextual based on event type
    version: str | None = None                          # released
    versions: list[CLEVersionSpecifier] | None = None   # endOf*, supersededBy
    support_id: str | None = None                       # endOfDevelopment, endOfSupport, endOfLife
    license: str | None = None                          # released
    superseded_by_version: str | None = None            # supersededBy
    identifiers: list[Identifier] | None = None         # componentRenamed
    event_id: int | None = None                         # withdrawn
    reason: str | None = None                           # withdrawn
    description: str | None = None                      # any event
    references: list[str] | None = None                 # any event (URIs)
```

#### `CLESupportDefinition`

```python
class CLESupportDefinition(_TeaModel):
    id: str                     # Required
    description: str            # Required
    url: str | None = None      # Optional
```

#### `CLEDefinitions`

```python
class CLEDefinitions(_TeaModel):
    support: list[CLESupportDefinition] | None = None
```

#### `CLE`

```python
class CLE(_TeaModel):
    events: list[CLEEvent]                      # Required, ordered by id descending
    definitions: CLEDefinitions | None = None   # Optional
```

### Event type ↔ field usage matrix

| Event type | version | versions | support_id | license | superseded_by_version | identifiers | event_id | reason |
|---|---|---|---|---|---|---|---|---|
| released | X | | | X | | | | |
| endOfDevelopment | | X | X | | | | | |
| endOfSupport | | X | X | | | | | |
| endOfLife | | X | X | | | | | |
| endOfDistribution | | X | | | | | | |
| endOfMarketing | | X | | | | | | |
| supersededBy | | X | | | X | | | |
| componentRenamed | | | | | | X | | |
| withdrawn | | | | | | | X | X |

### Example response

```json
{
  "events": [
    {
      "id": 3,
      "type": "endOfSupport",
      "effective": "2025-06-01T00:00:00Z",
      "published": "2025-01-01T00:00:00Z",
      "versions": [{"range": "vers:npm/>=1.0.0|<2.0.0"}],
      "supportId": "standard"
    },
    {
      "id": 2,
      "type": "endOfDevelopment",
      "effective": "2025-01-01T00:00:00Z",
      "published": "2024-06-01T00:00:00Z",
      "versions": [{"version": "1.0.0"}],
      "supportId": "standard"
    },
    {
      "id": 1,
      "type": "released",
      "effective": "2024-01-01T00:00:00Z",
      "published": "2024-01-01T00:00:00Z",
      "version": "1.0.0",
      "license": "Apache-2.0"
    }
  ],
  "definitions": {
    "support": [
      {
        "id": "standard",
        "description": "Standard product support policy",
        "url": "https://example.com/support/standard"
      }
    ]
  }
}
```

### Testing strategy

- Model tests: Validate all 9 event types parse from JSON, round-trip camelCase ↔ snake_case
- Client tests: Mock each of the 4 CLE endpoints, test 404/400 handling
- Edge cases: Empty events array, missing optional definitions, withdrawn event referencing another event

---

## 2. SemVer Version Matching

### Current behavior

`select_endpoint()` uses exact string matching: `supported_version in ep.versions`. This violates the spec.

### Spec requirement

> "The client MUST prioritize endpoints with the highest matching version supported both by the client and the endpoint based on SemVer 2.0.0 specification comparison rules."

Source: `discovery/readme.md`, lines 287-295

### New dependency

```toml
semver >= 3.0.4, < 4
```

The `semver` package (python-semver) implements strict SemVer 2.0.0 comparison. The `packaging.version` module uses PEP 440, which is incompatible with SemVer pre-release syntax (e.g., `0.3.0-beta.2`).

### Implementation

Replace `select_endpoint()` in `discovery.py`:

```python
from semver import Version

def select_endpoint(well_known: TeaWellKnown, supported_version: str) -> TeaEndpoint:
    """Select the best endpoint supporting the given version.

    Uses SemVer 2.0.0 comparison per spec. Exact version match required
    (pre-releases are distinct from releases per SemVer rules).
    Among matching endpoints, selects highest priority.
    """
    target = Version.parse(supported_version)
    candidates = []
    for ep in well_known.endpoints:
        for v in ep.versions:
            try:
                if Version.parse(v) == target:
                    candidates.append(ep)
                    break
            except ValueError:
                continue  # Skip malformed versions

    if not candidates:
        available = {v for ep in well_known.endpoints for v in ep.versions}
        raise TeaDiscoveryError(
            f"No compatible endpoint found for version {supported_version!r}. "
            f"Available versions: {sorted(available)}"
        )

    candidates.sort(
        key=lambda ep: ep.priority if ep.priority is not None else 1.0,
        reverse=True,
    )
    return candidates[0]
```

Note: For v0.2.0, we use **exact SemVer equality** (the client asks for `0.3.0-beta.2`, server must advertise exactly that). Range-based compatibility matching (e.g., "any 0.3.x") is a future consideration. The spec says "highest matching version supported both by the client and the endpoint" — implying exact match semantics.

### Testing strategy

- Exact version matches work
- Pre-release versions are distinct from releases (`0.3.0-beta.2` != `0.3.0`)
- Malformed version strings in server response are skipped gracefully
- Priority ordering preserved
- Existing tests continue to pass (version strings like `"1.0.0"` are valid SemVer)

---

## 3. Endpoint Failover with Retry

### Spec requirements

From `discovery/readme.md`, lines 319-331:

**Failover triggers (YES — retry next endpoint):**
- DNS resolution failure
- HTTP 5xx status codes
- TLS certificate validation failure

**No failover (STOP and report to user):**
- HTTP 401 Unauthorized
- HTTP 403 Forbidden

**Retry strategy:**
> "The client SHOULD implement an exponential backoff strategy for retries."

### Implementation approach

Use `urllib3.Retry` with `requests.adapters.HTTPAdapter`. This requires **zero new dependencies** (urllib3 is a transitive dependency of requests).

```python
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

retry = Retry(
    total=3,
    backoff_factor=0.5,                          # delays: 0s, 1s, 2s
    status_forcelist=(500, 502, 503, 504),        # 5xx failover
    allowed_methods=["GET", "HEAD", "OPTIONS"],   # safe methods only
    raise_on_status=False,                        # let _raise_for_status handle it
)
adapter = HTTPAdapter(max_retries=retry)
session.mount("https://", adapter)
session.mount("http://", adapter)
```

### Multi-endpoint failover

Beyond single-endpoint retry, the spec requires trying the **next endpoint** on failure. This is a higher-level concern than urllib3.Retry.

New logic in `TeaClient.from_well_known()`:

```python
@classmethod
def from_well_known(cls, domain, *, token=None, timeout=30.0, version=TEA_SPEC_VERSION):
    well_known = fetch_well_known(domain, timeout=timeout)
    candidates = _get_sorted_endpoints(well_known, version)

    last_error = None
    for endpoint in candidates:
        base_url = f"{endpoint.url.rstrip('/')}/v{version}"
        try:
            client = cls(base_url=base_url, token=token, timeout=timeout)
            # Optionally verify endpoint is reachable (light health check)
            return client
        except (TeaConnectionError, TeaServerError) as exc:
            last_error = exc
            continue  # Try next endpoint

    if last_error:
        raise last_error
    raise TeaDiscoveryError(f"No compatible endpoint found for version {version!r}")
```

### Configuration

Add optional retry parameters to `TeaHttpClient`:

```python
class TeaHttpClient:
    def __init__(
        self,
        base_url: str,
        *,
        token: str | None = None,
        timeout: float = 30.0,
        max_retries: int = 3,
        backoff_factor: float = 0.5,
    ):
```

### Testing strategy

- Mock 5xx responses to verify retry behavior
- Mock sequential endpoint failures to verify failover
- Verify 401/403 does NOT trigger failover
- Verify retry count limits
- Verify backoff delay (using time mocking or fast tests)

---

## 4. mTLS Support

### Spec context

From `auth/readme.md`:

> "Two methods are supported: HTTP Bearer Token Authentication and Mutual TLS with verifiable client and server certificates."

### Implementation

The `requests` library has built-in mTLS support via the `cert` parameter. No new dependencies.

```python
from dataclasses import dataclass
from pathlib import Path

@dataclass(frozen=True)
class MtlsConfig:
    """Client certificate configuration for mutual TLS."""
    client_cert: Path
    client_key: Path
    ca_bundle: Path | None = None  # None = use system CA store
```

Add to `TeaHttpClient.__init__()`:

```python
def __init__(
    self,
    base_url: str,
    *,
    token: str | None = None,
    timeout: float = 30.0,
    mtls: MtlsConfig | None = None,
):
    # ... existing setup ...
    if mtls:
        self._session.cert = (str(mtls.client_cert), str(mtls.client_key))
        if mtls.ca_bundle:
            self._session.verify = str(mtls.ca_bundle)
```

Surface in `TeaClient`:

```python
class TeaClient:
    def __init__(self, base_url, *, token=None, timeout=30.0, mtls=None):
        self._http = TeaHttpClient(base_url=base_url, token=token, timeout=timeout, mtls=mtls)
```

### Limitation

`requests` does not support encrypted (password-protected) private keys. If needed, httpx migration (v0.3.0) will unlock `ssl.SSLContext` support with passwords.

### Testing strategy

- Verify cert/key paths are set on session
- Verify ca_bundle overrides session.verify
- Verify None ca_bundle leaves default system CA

---

## 5. Basic Auth Support

### Spec context

The OpenAPI spec defines both `bearerAuth` and `basicAuth` at the global security level:

```yaml
security:
  - bearerAuth: []
  - basicAuth: []
```

### Implementation

Add `basic_auth` parameter as alternative to `token`:

```python
class TeaHttpClient:
    def __init__(
        self,
        base_url: str,
        *,
        token: str | None = None,
        basic_auth: tuple[str, str] | None = None,  # (username, password)
        timeout: float = 30.0,
        mtls: MtlsConfig | None = None,
    ):
        # ... existing setup ...
        if token and basic_auth:
            raise ValueError("Cannot use both token and basic_auth")
        if token:
            self._session.headers["authorization"] = f"Bearer {token}"
        elif basic_auth:
            self._session.auth = basic_auth
```

### Testing strategy

- Verify basic auth header is sent
- Verify mutual exclusion (token + basic_auth raises ValueError)
- Verify request includes `Authorization: Basic ...` header

---

## 6. CLI (`tea-cli`)

### Overview

A command-line interface for the TEA consumer API, packaged as an optional extra (`libtea[cli]`). Uses typer for the CLI framework. The CLI is a thin layer that calls existing `TeaClient` methods and prints JSON to stdout.

### Installation

- `pip install libtea` — library only, no typer
- `pip install libtea[cli]` — library + CLI
- Running `tea-cli` without `[cli]` extra shows: `Error: CLI dependencies not installed. Run: pip install libtea[cli]`

### Entry point

```toml
[project.scripts]
tea-cli = "libtea.cli:app"

[project.optional-dependencies]
cli = ["typer>=0.12.0,<1"]
```

### File structure

Single module: `libtea/cli.py`. No business logic — just argument parsing, client construction, and JSON output.

### Global options

```
tea-cli [OPTIONS] COMMAND

Options:
  --base-url URL      TEA server base URL (or env: TEA_BASE_URL)
  --token TOKEN       Bearer token (or env: TEA_TOKEN)
  --domain DOMAIN     Discover server from domain's .well-known/tea
  --timeout FLOAT     Request timeout in seconds [default: 30.0]
  --use-http          Use HTTP instead of HTTPS for discovery [default: false]
  --port INT          Port for well-known resolution [default: 443/80]
  --version           Show version
  --help              Show help
```

**Server resolution** — mutually exclusive:
- `--base-url` → use directly
- `--domain` → discover via `.well-known/tea`
- Neither → error with guidance message

**Auth resolution order:**
1. `--token` flag
2. `TEA_TOKEN` env var
3. No auth (public access)

### Commands

| Command | Description | Key arguments |
|---------|-------------|---------------|
| `discover` | Resolve a TEI to product release UUID(s) | `TEI` (positional) |
| `search-products` | Search products by identifier | `--id-type`, `--id-value`, `--page-offset`, `--page-size` |
| `search-releases` | Search product releases by identifier | `--id-type`, `--id-value`, `--page-offset`, `--page-size` |
| `get-product` | Get a product by UUID | `UUID` (positional) |
| `get-release` | Get a product or component release by UUID | `UUID` (positional), `--component` flag |
| `get-collection` | Get a collection | `UUID` (positional), `--version INT`, `--component` flag. Defaults to latest |
| `get-artifact` | Get artifact metadata by UUID | `UUID` (positional) |
| `download` | Download an artifact file | `URL` (positional), `DEST` (positional), `--checksum` (repeatable: `ALG:VALUE`) |
| `inspect` | Full flow: TEI → discovery → releases → artifacts | `TEI` (positional) |

### Output

All commands print JSON to stdout. Errors go to stderr. Exit code 0 on success, 1 on error.

For model objects, serialize via Pydantic's `.model_dump(mode="json", by_alias=True)` to produce camelCase JSON matching the TEA spec.

### `inspect` command flow

The `inspect` command implements a full TEA consumer flow (like rearm's `full_tea_flow`):

1. Discover product release UUIDs from TEI
2. For each product release: fetch release details
3. For each component: fetch component release with latest collection
4. Print structured JSON with all artifacts and download URLs

### Testing strategy

- Test each command with mocked HTTP responses
- Test global option validation (mutually exclusive `--base-url`/`--domain`)
- Test env var fallback for `--token`
- Test error output formatting

---

## 7. Regex Removal

Remove all 3 regex patterns from the codebase. Zero `import re` remaining.

### 7.1 `_SAFE_PATH_SEGMENT_RE` (client.py)

**Current:** `re.compile(r"^[a-zA-Z0-9\-]{1,128}$")`

**Replace with:**

```python
_SAFE_PATH_CHARS = frozenset("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-")

def _validate_path_segment(value: str, name: str = "uuid") -> str:
    if not value or len(value) > 128 or not all(c in _SAFE_PATH_CHARS for c in value):
        raise TeaValidationError(
            f"Invalid {name}: {value!r}. "
            "Must contain only alphanumeric characters and hyphens, max 128 characters."
        )
    return value
```

### 7.2 `_SEMVER_RE` (discovery.py)

**Current:** `re.compile(r"^(?P<major>\d+)\.(?P<minor>\d+)(?:\.(?P<patch>\d+))?(?:-(?P<pre>[0-9A-Za-z.-]+))?$")`

**Replace with string splitting:**

```python
def __init__(self, version_str: str):
    # Split pre-release: "1.2.3-beta.2" -> "1.2.3", "beta.2"
    if "-" in version_str:
        ver_part, pre_part = version_str.split("-", 1)
    else:
        ver_part, pre_part = version_str, None

    # Split version: "1.2.3" -> ["1", "2", "3"]
    parts = ver_part.split(".")
    if len(parts) < 2 or len(parts) > 3:
        raise ValueError(...)
    if not all(p.isdigit() for p in parts):
        raise ValueError(...)

    self.major = int(parts[0])
    self.minor = int(parts[1])
    self.patch = int(parts[2]) if len(parts) == 3 else 0
    self.pre = tuple(self._parse_pre(pre_part)) if pre_part else ()
```

### 7.3 `_DOMAIN_RE` (discovery.py)

**Current:** `re.compile(r"^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$")`

**Replace with label-by-label validation:**

```python
_DOMAIN_LABEL_CHARS = frozenset("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-")

def _is_valid_domain(domain: str) -> bool:
    if not domain:
        return False
    labels = domain.split(".")
    for label in labels:
        if not label or len(label) > 63:
            return False
        if label[0] == "-" or label[-1] == "-":
            return False
        if not all(c in _DOMAIN_LABEL_CHARS for c in label):
            return False
    return True
```

### Testing strategy

All existing tests pass unchanged — same validation rules, different implementation.

---

## 8. Discovery Enhancements

### `fetch_well_known` gains `scheme` and `port` parameters

Enables parity with rearm's `--usehttp` and `--useport` flags.

```python
def fetch_well_known(
    domain: str,
    *,
    timeout: float = 10.0,
    scheme: str = "https",
    port: int | None = None,
) -> TeaWellKnown:
    if scheme not in ("http", "https"):
        raise TeaDiscoveryError(f"Invalid scheme: {scheme!r}. Must be 'http' or 'https'.")

    default_port = 80 if scheme == "http" else 443
    resolved_port = port if port is not None else default_port

    if resolved_port == default_port:
        url = f"{scheme}://{domain}/.well-known/tea"
    else:
        url = f"{scheme}://{domain}:{resolved_port}/.well-known/tea"
    # ... rest of existing logic
```

### Testing strategy

- Test HTTP scheme constructs `http://` URL
- Test custom port is included in URL
- Test default ports (443/80) are omitted from URL
- Test invalid scheme raises error

---

## 9. Spec Alignment Fixes

### `DiscoveryInfo.servers` min_length

```python
class DiscoveryInfo(_TeaModel):
    product_release_uuid: str
    servers: list[TeaServerInfo] = Field(min_length=1)  # spec: minItems: 1
```

### `IdentifierType.UDI` disclaimer

```python
class IdentifierType(StrEnum):
    CPE = "CPE"
    TEI = "TEI"
    PURL = "PURL"
    UDI = "UDI"  # Not in spec's identifier-type enum; included for forward-compatibility
```

---

## New dependency summary

| Package | Version | Purpose | Type |
|---------|---------|---------|------|
| `semver` | >= 3.0.4, < 4 | SemVer 2.0 version comparison | Runtime |
| `typer` | >= 0.12.0, < 1 | CLI framework | Optional (`[cli]` extra) |

`urllib3.Retry` and mTLS are built into existing `requests`/`urllib3` stack. `typer` is only installed with `pip install libtea[cli]`.

---

## File changes summary

| File | Changes |
|------|---------|
| `libtea/models.py` | Add 6 CLE models, add `min_length=1` to `DiscoveryInfo.servers` |
| `libtea/client.py` | Add 4 CLE methods, update `__init__` for mtls/basic_auth, update `from_well_known` for failover, remove regex |
| `libtea/_http.py` | Add `max_retries`/`backoff_factor`, `MtlsConfig`, `basic_auth`, retry adapter |
| `libtea/discovery.py` | Replace `select_endpoint()` with SemVer-based matching, remove regexes, add `scheme`/`port` params |
| `libtea/cli.py` | New file: typer CLI with all commands |
| `pyproject.toml` | Add `semver` dep, add `[cli]` optional extra with typer, bump to 0.2.0 |
| `tests/test_models.py` | CLE model tests |
| `tests/test_client.py` | CLE endpoint tests |
| `tests/test_discovery.py` | SemVer matching tests, scheme/port tests |
| `tests/test_http.py` | Retry, failover, mTLS, basic auth tests |
| `tests/test_cli.py` | New file: CLI command tests |

---

## Migration notes

### Breaking changes

- `DiscoveryInfo.servers` now requires at least 1 element (`min_length=1`). Previously accepted empty lists. This matches the spec and is unlikely to affect real-world usage.
- Regex removal changes internal implementation but preserves identical validation behavior.

### Deprecations: None

---

## References

- TEA consumer OpenAPI spec: `/tmp/transparency-exchange-api/spec/openapi.yaml`
- TEA discovery spec: `/tmp/transparency-exchange-api/discovery/readme.md`
- TEA auth spec: `/tmp/transparency-exchange-api/auth/readme.md`
- Well-known schema: `/tmp/transparency-exchange-api/discovery/tea-well-known.schema.json`
- CLE PR: [#213](https://github.com/CycloneDX/transparency-exchange-api/pull/213) (merged Feb 20, 2026)
- ECMA-428 (CLE): [ecma-international.org](https://ecma-international.org/publications-and-standards/standards/ecma-428/)
- SemVer 2.0: [semver.org](https://semver.org/)
- python-semver: [PyPI](https://pypi.org/project/semver/)
- Rearm CLI (reference): `/tmp/rearm-cli/cmd/tea.go`
- Oolong server (reference): `/tmp/rearm-cli/cmd/oolong.go`
